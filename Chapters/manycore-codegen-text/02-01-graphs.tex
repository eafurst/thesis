\section{The Graph Abstraction}\label{thesis:background:graphproc}
\todo{talk about graph processing at a high level, talk about related data, maybe storage format?}
\section{Graph Topology}\label{thesis:background:topology}
\todo{planar vs. scale-free, properties of each}
\section{Graphs used in this Thesis}\label{thesis:background:graphs}
\todo{table of all graphs + their properties, explain in text about the choices}

\begin{table*}[h]
\centering
\begin{tabular}{lllll}
\toprule
\textbf{Name} & \textbf{Scale} & \textbf{Vertices} & \textbf{Edges} & \textbf{Properties} \\ \midrule
\kron & 18 & 262,144 & 4,194,304 & Synthetic, scale-free\\
\kron & 20 & 1,048,576 & 16,777,216 & Synthetic, scale-free\\
\kron & 22 & 4,194,304 & 67,108,864 & \\
Pokec & 20.5 & 1,632,803 & 30,622,564 & \\
LiveJournal (lj) & 22 & 3,997,962 & 34,681,189 & \\
Hollywood (hw) & & & & \\
RoadCA & & & & \\
RoadCentral & & & & \\
RoadUSA & & & & \\
\bottomrule
\end{tabular}
\caption{List of graphs used in this thesis and their properties.\todo{more on caption, cite each graph, fill in}}
\end{table*}

\section{Algorithms used in this Thesis}\label{thesis:background:algorithms}
%\todo{explain bfs, sssp (delta + bellmanford), pr, cc, bc, etc. in detail}
In this thesis we explore a variety of graph processing algorithms. 
We select them based on their popularity in graph-processing evaluations~\cite{beamer2016thesis} and for the different behaviors that they exhibit.
The algorithms we examine can be classified as traversal-centric or compute-centric algorithms. 
Traversal-centric or frontier-based algorithms start from a given source vertex and perform computation on vertices by traversing outwards from the source vertex.
Compute-centric algorithms operate on the entire graph in parallel and tend to iteratively apply updates until the algorithm converges.

\paragraph{Breadth First Search (BFS)}\mbox{}\\
BFS is a building block of many graph algorithms. 
It is not an algorithm but really a graph traversal order. 
BFS visits every vertex at a given depth of the graph before moving on to the next depth level.
We turn it into an algorithm by discovering and tracking the parent vertex ID of each vertex reachable from a given source vertex.

\paragraph{Single Source Shortest Path (SSSP)}\mbox{}\\
SSSP is an algorithm that builds off of BFS to compute the distances of the shortest paths from a given source vertex to every other reachable vertex in the graph.
This is usually performed on a weighted graph, so the weights of edges are used in calculating the distance of a path.
We only consider graphs with non-negative edge weights in this work.
We examine two different SSSP algorithms, frontier-based Bellman-Ford and Delta-stepping.

Frontier-based Bellman-Ford trades off repeated accesses to edges for increased parallelism. 
It uses relaxation where approximations of the distances to each vertex are replaced by shorter distances until the algorithm converges on the correct solution.
Unlike Dijkstra's, the classical SSSP algorithm, there is no notion of priority in Bellman-Ford and all edges active in the frontier are relaxed in every iteration.

The delta-stepping algorithm~\cite{meyer2003delta} increases parallelism by using a notion of relaxed priority. 
Delta-stepping coarsely sorts the vertices of the graph by distance into buckets of width $\Delta$.
This allows for all vertices in a bucket to be processed in parallel. 
Like Bellman-Ford, this does result in some vertices being processed multiple times, but the frequency with which this occurs can be reduced by reducing the value of $\Delta$.
If $\Delta=1$, the algorithm effectively becomes Dijkstra's, and if $\Delta=\inf$, the algorithm behaves like Bellman-Ford. 

\paragraph{PageRank (PR)}\mbox{}\\
PR calculates the importance of each vertex in a graph. 

\paragraph{Connected Components (CC)}

\paragraph{Betweenness Centrality (BC)} 